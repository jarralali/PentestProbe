import ssl
import socket
import whois
import requests
from OpenSSL import SSL
from pyfiglet import figlet_format
import dns.resolver  # Import dnspython for DNS resolution
import ipaddress  # Import ipaddress module for IP address handling
import pyudev

# Print the tool's title
def print_title():
    title = figlet_format("Pentest Probe v1.1")
    author = "By Muhammad Ali Jarral"
    print(title)
    print(author)

# Step 1: Fetch SSL certificate details
def get_ssl_certificate(domain):
    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)
    conn.settimeout(5.0)

    try:
        conn.connect((domain, 443))
        cert = conn.getpeercert()
        return cert
    except Exception as e:
        return str(e)

# Step 2: Determine SSL/TLS version
def get_ssl_version(domain):
    context = SSL.Context(SSL.SSLv23_METHOD)
    conn = SSL.Connection(context, socket.socket(socket.AF_INET))

    try:
        conn.connect((domain, 443))
        conn.do_handshake()
        ssl_version = conn.get_protocol_version_name()
        return ssl_version
    except Exception as e:
        return str(e)

# Step 3: Categorize SSL/TLS version
def categorize_ssl_version(ssl_version):
    if 'TLSv1.3' in ssl_version:
        return 'Excellent'
    elif 'TLSv1.2' in ssl_version:
        return 'Good'
    elif 'TLSv1.1' in ssl_version or 'TLSv1' in ssl_version:
        return 'Poor'
    else:
        return 'Unknown'

# Step 4: Get domain information
def get_domain_info(domain):
    try:
        domain_info = whois.whois(domain)
        return domain_info
    except Exception as e:
        return str(e)

# Additional steps for injection checks
sql_injection_payloads = ["' OR '1'='1", "'; DROP TABLE users; --"]
xss_payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]

def stealth_check_sql_injection(url, payload):
    try:
        response = requests.get(url, params={'input': payload})
        if "error" not in response.text.lower():
            return True, url, payload, response.text
    except Exception as e:
        return False, url, payload, str(e)
    return False, url, payload, "No error detected"

def stealth_check_xss(url, payload):
    try:
        response = requests.get(url, params={'input': payload})
        if payload in response.text:
            return True, url, payload, response.text
    except Exception as e:
        return False, url, payload, str(e)
    return False, url, payload, "Payload not reflected"

def ai_automated_attack(urls, payloads, check_function):
    results = []
    for url in urls:
        for payload in payloads:
            is_vulnerable, tested_url, tested_payload, output = check_function(url, payload)
            results.append((is_vulnerable, tested_url, tested_payload, output))
    return results

def check_broken_access_control(urls):
    results = []
    paths_to_check = ['/admin', '/login', '/wp-admin', '/admin.php']  # Add more paths as needed
    for url in urls:
        try:
            for path in paths_to_check:
                response = requests.get(url + path)
                if response.status_code == 200:
                    results.append((url + path, response.status_code))
        except Exception as e:
            results.append((url + path, str(e)))
    return results

# Function to retrieve list of domains and subdomains
def get_domain_subdomains(domain):
    try:
        subdomains = []
        paths_to_check = ['/admin', '/login', '/wp-admin', '/admin.php']  # Add more paths as needed
        answers = dns.resolver.resolve(domain, 'A')
        for answer in answers:
            subdomains.append(answer.to_text())
            for path in paths_to_check:
                subdomains.append(answer.to_text() + path)
        return subdomains
    except Exception as e:
        return [str(e)]

# Function to check if IP is public or private
def check_ip_type(ip):
    try:
        ip_obj = ipaddress.ip_address(ip)
        if ip_obj.is_private:
            return 'Private'
        else:
            return 'Public'
    except ValueError:
        return 'Invalid IP'

# Function to perform additional checks on private IPs
def check_private_ip(ip):
    try:
        ip_obj = ipaddress.ip_address(ip)
        if ip_obj.is_private:
            # Perform additional checks here if needed
            if ip.startswith('192.168.1'):  # Example of checking specific flags
                return f'Private IP with special flag detected: {ip}'
            else:
                return 'Private IP'
        else:
            return 'Public IP'
    except ValueError:
        return 'Invalid IP'

# Monitor USB events for mobile device connection
def monitor_usb_events():
    context = pyudev.Context()
    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by(subsystem='usb')

    for device in iter(monitor.poll, None):
        if device.action == 'add':
            print("Device connected:")
            print(f"  - Device Node: {device.device_node}")
            print(f"  - Vendor ID: {device.get('ID_VENDOR_ID')}")
            print(f"  - Product ID: {device.get('ID_MODEL_ID')}")
            print(f"  - Serial Number: {device.get('ID_SERIAL_SHORT')}")
            print(f"  - Manufacturer: {device.get('ID_VENDOR')}")
            # Add more detailed information retrieval or actions here
            return True
    return False

# Main function to run all checks
def main(domain):
    print(f"Starting SSL scan for {domain}\n")
    
    cert = get_ssl_certificate(domain)
    ssl_version = get_ssl_version(domain)
    version_category = categorize_ssl_version(ssl_version)
    domain_info = get_domain_info(domain)

    # Print certificate details
    print(f"SSL/TLS Certificate Details for {domain}:\n")
    print(f"1. Subject (The entity the certificate is issued to):")
    for item in cert.get('subject', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n2. Issuer (The entity that issued the certificate):")
    for item in cert.get('issuer', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n3. Version: {cert.get('version', 'N/A')}")

    print(f"\n4. Serial Number: {cert.get('serialNumber', 'N/A')}")

    print(f"\n5. Validity Period:")
    print(f"   - Not Before: {cert.get('notBefore', 'N/A')}")
    print(f"   - Not After: {cert.get('notAfter', 'N/A')}")

    print(f"\n6. Subject Alternative Name (Other entities the certificate is valid for):")
    for item in cert.get('subjectAltName', []):
        print(f"   - {item[0]}: {item[1]}")

    print(f"\n7. OCSP (Online Certificate Status Protocol): {cert.get('OCSP', 'N/A')}")
    
    print(f"\n8. CA Issuers (Certificate Authority Issuers): {cert.get('caIssuers', 'N/A')}")

    print(f"\n9. CRL Distribution Points (Certificate Revocation List): {cert.get('crlDistributionPoints', 'N/A')}")

    print(f"\n10. SSL/TLS Version: {ssl_version} ({version_category})\n")

    # Print domain information
    if isinstance(domain_info, str):
        print(f"Error retrieving domain information: {domain_info}")
    else:
        print(f"Domain Information for {domain}:\n")
        print(f" - Registrar: {domain_info.get('registrar', 'N/A')}")
        print(f" - Creation Date: {domain_info.get('creation_date', 'N/A')}")
        print(f" - Expiration Date: {domain_info.get('expiration_date', 'N/A')}")
        print(f" - Updated Date: {domain_info.get('updated_date', 'N/A')}")
        print(f" - Name Servers: {', '.join(domain_info.get('name_servers', []))}")

    # Retrieve list of domains and subdomains
    print(f"\nDomains, Subdomains, and Paths for {domain}:\n")
    domain_list = get_domain_subdomains(domain)
    for subdomain in domain_list:
        print(f" - {subdomain}")

    # Ask user if they want to perform additional checks
    perform_sql_check = input("\nDo you want to perform SQL Injection checks? (yes/no): ").strip().lower()
    perform_xss_check = input("Do you want to perform XSS checks? (yes/no): ").strip().lower()
    perform_access_control_check = input("Do you want to perform Broken Access Control checks? (yes/no): ").strip().lower()

    urls_to_check = [f"http://{domain}", f"https://{domain}"]
    
    if perform_sql_check == 'yes':
        sql_results = ai_automated_attack(urls_to_check, sql_injection_payloads, stealth_check_sql_injection)
        print("\nSQL Injection Vulnerable URLs:")
        for is_vulnerable, tested_url, tested_payload, output in sql_results:
            if is_vulnerable:
                print(f" - URL: {tested_url}")
                print(f"   Payload: {tested_payload}")
                print(f"   Response: {output}\n")
            else:
                print(f" - {tested_url} is not vulnerable to SQL injection with payload {tested_payload}.")
    else:
        print("\nSQL Injection check skipped.")

    if perform_xss_check == 'yes':
        xss_results = ai_automated_attack(urls_to_check, xss_payloads, stealth_check_xss)
        print("\nXSS Vulnerable URLs:")
        for is_vulnerable, tested_url, tested_payload, output in xss_results:
            if is_vulnerable:
                print(f" - URL: {tested_url}")
                print(f"   Payload: {tested_payload}")
                print(f"   Response: {output}\n")
            else:
                print(f" - {tested_url} is not vulnerable to XSS with payload {tested_payload}.")
    else:
        print("\nXSS check skipped.")
    if perform_access_control_check == 'yes':
        access_control_vulnerable_urls = check_broken_access_control(urls_to_check)
        print("\nBroken Access Control Vulnerable URLs:")
        for url, status in access_control_vulnerable_urls:
            print(f" - URL: {url}")
            print(f"   Status: {status}\n")
    else:
        print("\nBroken Access Control check skipped.")

    # Check IP address type and perform additional checks for private IPs
    ip_address = socket.gethostbyname(domain)
    ip_type = check_ip_type(ip_address)
    print(f"\nIP Address Information:\n")
    print(f" - IP Address: {ip_address}")
    print(f" - IP Type: {ip_type}")

    if ip_type == 'Private':
        private_ip_details = check_private_ip(ip_address)
        print(f" - Additional Details: {private_ip_details}")

# Offer a menu for user to choose the desired service
def display_menu():
    print("\nSelect the desired service:")
    print("1. SSL/TLS Scan")
    print("2. SQL Injection Check")
    print("3. XSS Check")
    print("4. Broken Access Control Check")
    print("5. Monitor Mobile Device Connection")
    print("6. Exit")
    choice = input("Enter your choice (1-6): ").strip()
    return choice

if __name__ == "__main__":
    print_title()
    choice = display_menu()

    while choice != '6':
        if choice == '1':
            domain = input("Enter the domain to scan: ")
            main(domain)
        elif choice == '2':
            domain = input("Enter the domain to scan for SQL Injection: ")
            urls_to_check = [f"http://{domain}", f"https://{domain}"]
            sql_results = ai_automated_attack(urls_to_check, sql_injection_payloads, stealth_check_sql_injection)
            print("\nSQL Injection Vulnerable URLs:")
            for is_vulnerable, tested_url, tested_payload, output in sql_results:
                if is_vulnerable:
                    print(f" - URL: {tested_url}")
                    print(f"   Payload: {tested_payload}")
                    print(f"   Response: {output}\n")
                else:
                    print(f" - {tested_url} is not vulnerable to SQL injection with payload {tested_payload}.")
        elif choice == '3':
            domain = input("Enter the domain to scan for XSS: ")
            urls_to_check = [f"http://{domain}", f"https://{domain}"]
            xss_results = ai_automated_attack(urls_to_check, xss_payloads, stealth_check_xss)
            print("\nXSS Vulnerable URLs:")
            for is_vulnerable, tested_url, tested_payload, output in xss_results:
                if is_vulnerable:
                    print(f" - URL: {tested_url}")
                    print(f"   Payload: {tested_payload}")
                    print(f"   Response: {output}\n")
                else:
                    print(f" - {tested_url} is not vulnerable to XSS with payload {tested_payload}.")
        elif choice == '4':
            domain = input("Enter the domain to scan for Broken Access Control: ")
            urls_to_check = [f"http://{domain}", f"https://{domain}"]
            access_control_vulnerable_urls = check_broken_access_control(urls_to_check)
            print("\nBroken Access Control Vulnerable URLs:")
            for url, status in access_control_vulnerable_urls:
                print(f" - URL: {url}")
                print(f"   Status: {status}\n")
        elif choice == '5':
            print("Monitoring mobile device connection...")
            device_connected = monitor_usb_events()
            if device_connected:
                print("Mobile device connected.")
            else:
                print("No mobile device connected.")
        else:
            print("Invalid choice. Please try again.")

        choice = display_menu()
    print("Exiting the tool. Goodbye!")
